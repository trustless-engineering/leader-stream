<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Solana Leader Path</title>
        <meta name="leader-stream-url" content="{{leader_stream_url}}" />
        <meta
            name="description"
            content="Globe view of upcoming Solana leaders with geolocated TPU endpoints."
        />
        <meta property="og:title" content="Solana Leader Path" />
        <meta
            property="og:description"
            content="Globe view of upcoming Solana leaders with geolocated TPU endpoints."
        />
        <meta property="og:type" content="website" />
        <meta property="og:image" content="/og.svg" />
        <meta property="og:image:width" content="1200" />
        <meta property="og:image:height" content="630" />
        <meta property="og:image:type" content="image/svg+xml" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="Solana Leader Path" />
        <meta
            name="twitter:description"
            content="Globe view of upcoming Solana leaders with geolocated TPU endpoints."
        />
        <meta name="twitter:image" content="/og.svg" />
        <link rel="stylesheet" href="/styles.css?{{cache_bust}}" />
        <style>
            :root {
                --map-accent: var(--accent-1, #a855f7);
                --map-accent-strong: var(--accent-strong, #c084fc);
                --map-accent-alt: var(--accent-2, #22d3ee);
            }

            .map-page .hero {
                align-items: flex-end;
            }

            .map-panel {
                display: flex;
                flex-direction: column;
                gap: 16px;
            }

            .globe-wrap {
                display: grid;
                grid-template-columns: 1.8fr 1fr;
                gap: 16px;
                align-items: stretch;
            }

            .globe {
                min-height: 520px;
                background: rgba(255, 255, 255, 0.02);
                border: 1px solid rgba(255, 255, 255, 0.08);
                border-radius: 18px;
                overflow: hidden;
            }

            .map-sidebar {
                background: rgba(255, 255, 255, 0.02);
                border: 1px solid rgba(255, 255, 255, 0.08);
                border-radius: 18px;
                padding: 16px;
                display: flex;
                flex-direction: column;
                gap: 12px;
                min-height: 520px;
            }

            .path-list {
                list-style: none;
                padding: 0;
                margin: 0;
                display: flex;
                flex-direction: column;
                gap: 10px;
                overflow-y: auto;
            }

            .path-list li {
                background: rgba(255, 255, 255, 0.02);
                border: 1px solid rgba(255, 255, 255, 0.05);
                border-radius: 12px;
                padding: 10px 12px;
                display: grid;
                grid-template-columns: auto 1fr;
                gap: 6px 12px;
                align-items: center;
            }

            .path-list .slot {
                font-weight: 600;
                color: var(--map-accent-strong);
                font-feature-settings: "tnum" on, "lnum" on;
            }

            .path-list .location {
                font-size: 0.95rem;
            }

            .path-list .leader {
                grid-column: 1 / span 2;
                font-family: "JetBrains Mono", "SFMono-Regular", Menlo, Consolas, monospace;
                font-size: 0.9rem;
                color: rgba(255, 255, 255, 0.8);
                word-break: break-all;
            }

            .map-meta {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 10px;
            }

            .meta-card {
                background: rgba(255, 255, 255, 0.02);
                border: 1px solid rgba(255, 255, 255, 0.05);
                border-radius: 12px;
                padding: 10px 12px;
            }

            .meta-label {
                display: block;
                font-size: 0.85rem;
                color: rgba(255, 255, 255, 0.7);
                margin-bottom: 4px;
            }

            .meta-value {
                font-weight: 600;
                font-feature-settings: "tnum" on, "lnum" on;
            }

            .follow-toggle {
                display: flex;
                align-items: center;
                gap: 8px;
                text-transform: none;
                letter-spacing: 0;
                font-size: 0.95rem;
            }

            .follow-toggle input {
                width: 18px;
                height: 18px;
                accent-color: var(--map-accent-strong);
            }

            @media (max-width: 960px) {
                .globe-wrap {
                    grid-template-columns: 1fr;
                }

                .map-sidebar {
                    min-height: auto;
                }
            }
        </style>
        <script src="https://cdn.jsdelivr.net/npm/globe.gl"></script>
    </head>
    <body class="map-page">
        <div class="backdrop" aria-hidden="true">
            <div class="glow one"></div>
            <div class="glow two"></div>
            <div class="glow three"></div>
            <div class="grain"></div>
        </div>
        <main class="page">
            <div class="footer footer-top">
                <a class="footer-link" href="/">Home</a>
                &middot;
                <a class="footer-link" href="/docs.html">Docs</a>
                &middot; Leader path globe
            </div>
            <header class="hero">
                <div class="hero-main">
                    <div class="badge">
                        <span class="pulse"></span>
                        Solana Mainnet - Live Leader Path
                    </div>
                    <h1>
                        <span class="title-top">Solana TPU</span>
                        <span class="title-gradient">Leader Map</span>
                    </h1>
                    <div id="status" class="status">Ready.</div>
                </div>
                <aside class="hero-card">
                    <p class="card-copy">
                        Explore the upcoming leader schedule on a live 3D globe. We geolocate TPU
                        endpoints with the MaxMind database and plot the next validators.
                    </p>
                    <span class="card-label">Live updates</span>
                    <p class="sub">
                        Updates follow the same leader stream as the main view. Refreshes trigger
                        when the leader falls outside the current window or you change the limit.
                    </p>
                </aside>
            </header>
            <section class="panel map-panel">
                <div class="panel-head">
                    <div>
                        <h2>Leader path</h2>
                        <p class="sub">
                            Consecutive leaders are connected in order. Only TPUs with valid
                            geolocation appear on the globe.
                        </p>
                    </div>
                    <div id="meta" class="meta"></div>
                </div>
                <div class="controls">
                    <div class="field">
                        <span>Follow leader</span>
                        <label class="follow-toggle" for="follow-current">
                            <input type="checkbox" id="follow-current" checked />
                            Follow current leader
                        </label>
                    </div>
                </div>
                <div class="globe-wrap">
                    <div id="globe" class="globe" role="img" aria-label="Leader path globe"></div>
                    <div class="map-sidebar">
                        <div class="map-meta">
                            <div class="meta-card">
                                <span class="meta-label">Leaders</span>
                                <span id="leaders-count" class="meta-value">-</span>
                            </div>
                            <div class="meta-card">
                                <span class="meta-label">With location</span>
                                <span id="geo-count" class="meta-value">-</span>
                            </div>
                            <div class="meta-card">
                                <span class="meta-label">Current slot</span>
                                <span id="current-slot" class="meta-value">-</span>
                            </div>
                        </div>
                        <ol id="path-list" class="path-list" aria-live="polite">
                            <li>Loading path…</li>
                        </ol>
                    </div>
                </div>
            </section>
        </main>
        <script>
            (function () {
                const statusEl = document.getElementById("status");
                const metaEl = document.getElementById("meta");
                const globeHost = document.getElementById("globe");
                const pathList = document.getElementById("path-list");
                const leadersCountEl = document.getElementById("leaders-count");
                const geoCountEl = document.getElementById("geo-count");
                const currentSlotEl = document.getElementById("current-slot");
                const followToggle = document.getElementById("follow-current");
                const leaderStreamUrl =
                    document.querySelector('meta[name="leader-stream-url"]')?.content ||
                    "/api/leader-stream";
                const rootStyles = getComputedStyle(document.documentElement);
                const accent = (rootStyles.getPropertyValue("--map-accent") || "#a855f7").trim();
                const accentAlt = (rootStyles.getPropertyValue("--map-accent-alt") || "#22d3ee").trim();
                const accentStrong = (rootStyles.getPropertyValue("--map-accent-strong") || "#c084fc").trim();
                const CLUSTER_STEP = 0.6;
                const CLUSTER_SAMPLE_LIMIT = 3;
                const BASE_POINT_RADIUS = 0.45;
                const MAX_POINT_RADIUS = 1.35;
                const BASE_ALTITUDE = 0.01;
                const MAX_ALTITUDE = 0.09;
                const FOLLOW_ALTITUDE = 1.4;
                const FLASH_COLOR = accentStrong || accent || "#c084fc";
                const DEFAULT_LIMIT = 5000;
                let globe;
                let refreshTimer = null;
                let isLoading = false;
                let pendingRefresh = false;
                let currentSlotValue = null;
                let currentLeaderId = null;
                let currentClusterKey = null;
                let lastFocusedClusterKey = null;
                let leaderData = [];
                let leaderRuns = [];
                let pointData = [];
                let leaderSet = new Set();
                let leaderClusterMap = new Map();
                let geolocatedCount = 0;
                let flashState = false;

                function setStatus(message) {
                    if (statusEl) {
                        statusEl.textContent = message;
                    }
                }

                function formatLocation(row) {
                    if (row.locationLabel) {
                        return row.locationLabel;
                    }
                    if (row.city && row.country) {
                        return `${row.city}, ${row.country}`;
                    }
                    if (row.country) {
                        return row.country;
                    }
                    return row.ip || "Location unavailable";
                }

                function buildUniqueLeaders(rows) {
                    const map = new Map();
                    rows.forEach((row) => {
                        if (!row?.leader) {
                            return;
                        }
                        let entry = map.get(row.leader);
                        if (!entry) {
                            entry = {
                                leader: row.leader,
                                slot: row.slot,
                                count: 0,
                                ip: row.ip,
                                port: row.port,
                                latitude: null,
                                longitude: null,
                                city: null,
                                country: null,
                            };
                            map.set(row.leader, entry);
                        }
                        entry.count += 1;
                        if (row.slot != null && row.slot < entry.slot) {
                            entry.slot = row.slot;
                        }
                        if (entry.latitude == null && row.latitude != null && row.longitude != null) {
                            entry.latitude = row.latitude;
                            entry.longitude = row.longitude;
                            entry.city = row.city;
                            entry.country = row.country;
                            entry.ip = row.ip;
                            entry.port = row.port;
                        }
                    });

                    const leaders = Array.from(map.values()).sort((a, b) => a.slot - b.slot);
                    const points = leaders.filter(
                        (row) => row.latitude != null && row.longitude != null,
                    );
                    return { leaders, points };
                }

                function buildClusters(points) {
                    const clusters = new Map();
                    const leaderToCluster = new Map();
                    points.forEach((row) => {
                        if (row.latitude == null || row.longitude == null) {
                            return;
                        }
                        const key = `${Math.round(row.latitude / CLUSTER_STEP)}:${Math.round(
                            row.longitude / CLUSTER_STEP,
                        )}`;
                        let cluster = clusters.get(key);
                        if (!cluster) {
                            const locationLabel =
                                row.city && row.country
                                    ? `${row.city}, ${row.country}`
                                    : row.country || null;
                            cluster = {
                                latitude: 0,
                                longitude: 0,
                                validators: 0,
                                count: 0,
                                slot: row.slot ?? 0,
                                city: row.city ?? null,
                                country: row.country ?? null,
                                locationLabel,
                                locationKey: `${row.city || ""}|${row.country || ""}`,
                                clusterKey: key,
                                leaderSample: [],
                            };
                            clusters.set(key, cluster);
                        }
                        leaderToCluster.set(row.leader, key);
                        cluster.validators += 1;
                        cluster.count += row.count || 0;
                        cluster.latitude += row.latitude;
                        cluster.longitude += row.longitude;
                        if (row.slot != null && row.slot < cluster.slot) {
                            cluster.slot = row.slot;
                        }
                        if (cluster.locationLabel) {
                            const rowKey = `${row.city || ""}|${row.country || ""}`;
                            if (rowKey !== cluster.locationKey) {
                                cluster.locationLabel = "Multiple locations";
                            }
                        }
                        if (cluster.leaderSample.length < CLUSTER_SAMPLE_LIMIT) {
                            cluster.leaderSample.push(row.leader);
                        }
                    });

                    const clusterList = Array.from(clusters.values()).map((cluster) => ({
                        ...cluster,
                        latitude: cluster.latitude / cluster.validators,
                        longitude: cluster.longitude / cluster.validators,
                    }));

                    let maxCount = 1;
                    let maxValidators = 1;
                    clusterList.forEach((cluster) => {
                        if (cluster.count > maxCount) {
                            maxCount = cluster.count;
                        }
                        if (cluster.validators > maxValidators) {
                            maxValidators = cluster.validators;
                        }
                    });
                    clusterList.forEach((cluster) => {
                        const countScale = Math.sqrt(cluster.count / maxCount);
                        cluster.altitude =
                            BASE_ALTITUDE + (MAX_ALTITUDE - BASE_ALTITUDE) * countScale;
                        const validatorScale = Math.sqrt(cluster.validators / maxValidators);
                        cluster.radius =
                            BASE_POINT_RADIUS +
                            (MAX_POINT_RADIUS - BASE_POINT_RADIUS) * validatorScale;
                    });
                    return { clusters: clusterList, leaderToCluster };
                }

                function buildLeaderRuns(rows) {
                    if (!rows?.length) {
                        return [];
                    }
                    const sorted = rows
                        .filter((row) => row && row.leader != null && row.slot != null)
                        .slice()
                        .sort((a, b) => a.slot - b.slot);
                    const runs = [];
                    let current = null;
                    sorted.forEach((row) => {
                        const isNext =
                            current &&
                            row.leader === current.leader &&
                            row.slot === current.endSlot + 1;
                        if (!current || !isNext) {
                            current = {
                                leader: row.leader,
                                startSlot: row.slot,
                                endSlot: row.slot,
                                count: 1,
                                ip: row.ip ?? null,
                                port: row.port ?? null,
                                city: row.city ?? null,
                                country: row.country ?? null,
                            };
                            runs.push(current);
                        } else {
                            current.endSlot = row.slot;
                            current.count += 1;
                        }
                        if (!current.city && row.city) {
                            current.city = row.city;
                        }
                        if (!current.country && row.country) {
                            current.country = row.country;
                        }
                        if (!current.ip && row.ip) {
                            current.ip = row.ip;
                            current.port = row.port ?? current.port;
                        }
                    });
                    return runs;
                }

                function renderList(path) {
                    pathList.innerHTML = "";
                    if (!path.length) {
                        const item = document.createElement("li");
                        item.textContent = "No leaders yet.";
                        pathList.appendChild(item);
                        return;
                    }

                    path.slice(0, 40).forEach((row) => {
                        const item = document.createElement("li");
                        const slot = document.createElement("span");
                        slot.className = "slot";
                        const slotLabel =
                            row.startSlot === row.endSlot
                                ? `Slot ${row.startSlot}`
                                : `Slots ${row.startSlot}–${row.endSlot}`;
                        slot.textContent = slotLabel;

                        const location = document.createElement("span");
                        location.className = "location";
                        const until =
                            currentSlotValue != null
                                ? Math.max(row.startSlot - currentSlotValue, 0)
                                : null;
                        const untilLabel = until != null ? ` · in ${until} slots` : "";
                        location.textContent = `${formatLocation(row)} · ${row.count} slots${untilLabel}`;

                        const leader = document.createElement("span");
                        leader.className = "leader";
                        leader.textContent = row.leader;

                        item.appendChild(slot);
                        item.appendChild(location);
                        item.appendChild(leader);
                        pathList.appendChild(item);
                    });
                }

                function slotColor(slotsUntil, maxSlotsUntil) {
                    if (!maxSlotsUntil || maxSlotsUntil <= 0) {
                        return "rgb(0, 255, 0)";
                    }
                    const clamped = Math.max(0, Math.min(slotsUntil, maxSlotsUntil));
                    const t = 1 - clamped / maxSlotsUntil;
                    const green = Math.round(255 * t);
                    const blue = Math.round(255 * (1 - t));
                    return `rgb(0, ${green}, ${blue})`;
                }

                function pointColor(row) {
                    if (row.isCurrent) {
                        return flashState ? FLASH_COLOR : row.color || accentAlt;
                    }
                    return row.color || accentAlt;
                }

                function setGlobeData() {
                    const globeInstance = ensureGlobe();
                    if (!globeInstance) {
                        setStatus("Globe renderer unavailable.");
                        return;
                    }
                    resizeGlobe();
                    globeInstance.pointsData(pointData);
                    globeInstance.pointLat("latitude");
                    globeInstance.pointLng("longitude");
                    globeInstance.pointLabel((row) => {
                        const parts = [
                            `${row.validators} validators`,
                            `Earliest slot ${row.slot}`,
                            formatLocation(row),
                            `Slots: ${row.count}`,
                        ];
                        if (row.slotsUntil != null) {
                            parts.push(`Slots until: ${row.slotsUntil}`);
                        }
                        if (row.leaderSample?.length) {
                            parts.push(row.leaderSample.join("\n"));
                            const remaining = row.validators - row.leaderSample.length;
                            if (remaining > 0) {
                                parts.push(`+ ${remaining} more`);
                            }
                        }
                        return parts.join("\n");
                    });
                    globeInstance.arcsData([]);
                }

                function updateSlotColors() {
                    if (currentSlotValue == null || !pointData.length) {
                        return;
                    }
                    let maxSlotsUntil = 0;
                    pointData.forEach((row) => {
                        row.slotsUntil = Math.max(row.slot - currentSlotValue, 0);
                        if (row.slotsUntil > maxSlotsUntil) {
                            maxSlotsUntil = row.slotsUntil;
                        }
                    });
                    pointData.forEach((row) => {
                        row.color = slotColor(row.slotsUntil, maxSlotsUntil);
                        row.isCurrent =
                            currentClusterKey != null && row.clusterKey === currentClusterKey;
                    });
                    if (globe) {
                        globe.pointColor(pointColor);
                    }
                }

                function resizeGlobe() {
                    if (!globe || !globeHost) {
                        return;
                    }
                    const bounds = globeHost.getBoundingClientRect();
                    if (bounds.width && bounds.height) {
                        globe.width(bounds.width);
                        globe.height(bounds.height);
                    }
                }

                function ensureGlobe() {
                    if (globe || typeof Globe !== "function") {
                        return globe;
                    }
                    globe = Globe()(globeHost)
                        .globeImageUrl(
                            "https://unpkg.com/three-globe@2.30.0/example/img/earth-dark.jpg",
                        )
                        .bumpImageUrl(
                            "https://unpkg.com/three-globe@2.30.0/example/img/earth-topology.png",
                        )
                        .backgroundColor("rgba(0,0,0,0)")
                        .showAtmosphere(true)
                        .atmosphereColor(accent)
                        .atmosphereAltitude(0.18)
                        .pointRadius((row) => row.radius ?? BASE_POINT_RADIUS)
                        .pointAltitude((row) => row.altitude ?? BASE_ALTITUDE)
                        .pointColor(pointColor)
                        .arcColor(() => [accentAlt, accentStrong || accent])
                        .arcDashLength(0.35)
                        .arcDashGap(0.2)
                        .arcDashAnimateTime(2800)
                        .arcAltitudeAutoScale(true)
                        .arcStroke(0.6);
                    resizeGlobe();
                    window.addEventListener("resize", () => resizeGlobe());
                    return globe;
                }

                function focusOnCurrentLeader(animate = true) {
                    if (!followToggle?.checked || !currentClusterKey || !pointData.length) {
                        return;
                    }
                    if (currentClusterKey === lastFocusedClusterKey) {
                        return;
                    }
                    const target = pointData.find(
                        (row) => row.clusterKey === currentClusterKey,
                    );
                    if (!target) {
                        return;
                    }
                    const globeInstance = ensureGlobe();
                    if (!globeInstance) {
                        return;
                    }
                    globeInstance.pointOfView(
                        { lat: target.latitude, lng: target.longitude, altitude: FOLLOW_ALTITUDE },
                        animate ? 900 : 0,
                    );
                    lastFocusedClusterKey = currentClusterKey;
                }

                function applyData(data) {
                    const incoming = Array.isArray(data?.path) ? data.path : [];
                    if (typeof data?.currentSlot === "number") {
                        currentSlotValue = data.currentSlot;
                    }
                    const unique = buildUniqueLeaders(incoming);
                    leaderData = unique.leaders;
                    leaderSet = new Set(unique.leaders.map((row) => row.leader));
                    geolocatedCount = unique.points.length;
                    leaderRuns = buildLeaderRuns(incoming);
                    const clustered = buildClusters(unique.points);
                    pointData = clustered.clusters;
                    leaderClusterMap = clustered.leaderToCluster;
                    if (currentLeaderId) {
                        currentClusterKey = leaderClusterMap.get(currentLeaderId) || null;
                    }
                    if (currentClusterKey) {
                        lastFocusedClusterKey = null;
                    }

                    updateSlotColors();
                    setGlobeData();
                    renderList(
                        leaderRuns.filter(
                            (row) =>
                                currentSlotValue == null || row.endSlot >= currentSlotValue,
                        ),
                    );
                    focusOnCurrentLeader(false);

                    leadersCountEl.textContent = leaderData.length.toLocaleString();
                    geoCountEl.textContent = geolocatedCount.toLocaleString();
                    currentSlotEl.textContent = data?.currentSlot?.toLocaleString() ?? "-";
                    metaEl.textContent = `${geolocatedCount} leaders mapped across ${pointData.length} clusters`;
                    setStatus("Live.");
                }

                async function loadPath() {
                    if (refreshTimer) {
                        clearTimeout(refreshTimer);
                        refreshTimer = null;
                    }
                    if (isLoading) {
                        pendingRefresh = true;
                        return;
                    }
                    isLoading = true;
                    pendingRefresh = false;
                    setStatus("Loading leader path…");
                    try {
                        const response = await fetch(`/api/leader-path?limit=${DEFAULT_LIMIT}`, {
                            cache: "no-store",
                        });
                        if (!response.ok) {
                            throw new Error(`Request failed with status ${response.status}`);
                        }
                        const payload = await response.json();
                        applyData(payload);
                    } catch (err) {
                        console.error(err);
                        setStatus("Unable to load leader path.");
                        metaEl.textContent = "Location lookup unavailable.";
                    } finally {
                        refreshTimer = null;
                        isLoading = false;
                        if (pendingRefresh) {
                            pendingRefresh = false;
                            scheduleRefresh(0);
                        }
                    }
                }

                function scheduleRefresh(delay = 800) {
                    if (isLoading) {
                        pendingRefresh = true;
                        return;
                    }
                    if (refreshTimer) {
                        return;
                    }
                    refreshTimer = window.setTimeout(loadPath, delay);
                }

                function listenForStream() {
                    try {
                        const source = new EventSource(leaderStreamUrl);
                        source.onmessage = (event) => {
                            if (!event?.data) {
                                return;
                            }
                            let payload = null;
                            try {
                                payload = JSON.parse(event.data);
                            } catch (err) {
                                return;
                            }
                            const current = payload?.currentValidator;
                            if (!current) {
                                return;
                            }
                            currentLeaderId = current;
                            currentClusterKey = leaderClusterMap.get(current) || null;
                            flashState = !flashState;
                            if (typeof payload?.slot === "number") {
                                currentSlotValue = payload.slot;
                                if (currentSlotEl) {
                                    currentSlotEl.textContent = payload.slot.toLocaleString();
                                }
                                updateSlotColors();
                            }
                            focusOnCurrentLeader(true);
                            if (leaderRuns.length) {
                                renderList(
                                    leaderRuns.filter(
                                        (row) =>
                                            currentSlotValue == null ||
                                            row.endSlot >= currentSlotValue,
                                    ),
                                );
                            }
                            if (!leaderSet.size) {
                                return;
                            }
                            const nextLeader = payload?.nextValidator ?? null;
                            const hasCurrent = leaderSet.has(current);
                            const hasNext = !nextLeader || leaderSet.has(nextLeader);
                            if (!hasCurrent || !hasNext) {
                                scheduleRefresh(0);
                            }
                        };
                        source.onerror = () => {
                            setStatus("Live updates unavailable; retrying.");
                        };
                    } catch (err) {
                        console.warn("SSE unavailable", err);
                    }
                }

                if (followToggle) {
                    followToggle.addEventListener("change", () => {
                        if (followToggle.checked) {
                            lastFocusedClusterKey = null;
                            focusOnCurrentLeader(false);
                        }
                    });
                }

                loadPath();
                listenForStream();
            })();
        </script>
    </body>
</html>
